#include "DATA/Shaders/HLSL/FogOfWar/FogOfWar_VS.hls"
#include "DATA/Shaders/HLSL/DX9HalfPixelAdjust.hls"

#ifdef LOW_QUALITY_MODE
#undef CLOUD_SHADOWS
#endif

#if defined(CLOUD_SHADOWS) && defined(DISABLE_FOW)
#define CLOUDS_NEED_UV 1
#endif

#if !defined(NO_BAKED_LIGHTING) || defined(FEATURE_BAKED_PAINT)
#define NEED_ATLAS_UVS 1
#endif

/////////////////////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////////////////////
column_major float4x4 WORLD_MATRIX;
column_major float4x4 WORLD_MATRIX_INV; // used if particular snippets are used and optimized out if not
float3 MESH_CENTER;

struct VERTEX
{
    float3 m_Position       : X3D_VSIN_POSITION;
    float3 m_Normal         : X3D_VSIN_NORMAL;
    float2 m_Texcoord       : X3D_VSIN_TEXCOORD0;
    
    
#ifdef FEATURE_TANGENT
    float4 m_Tangent : X3D_VSIN_TEXCOORD6;
#endif
    // if the vertex color is used in either the vertex shader or pixel shader
    // we need the input
#if defined(FEATURE_VERTEX_COLOR_VS) || defined(FEATURE_VERTEX_COLOR)
    float4 m_Color : X3D_VSIN_COLOR0;
#endif
#if defined(NEED_ATLAS_UVS) || defined(CAPTURE_DIFFUSE)
    float2 m_AtlasTexcoord  : X3D_VSIN_TEXCOORD7;
#endif
};

struct INTERPOLANTS
{
    float4 m_Position      : POSITION;
    // we only need the interpolant if the vertex color is used in the pixel shader
#ifdef FEATURE_VERTEX_COLOR
    float4 m_VertexColor : COLOR0;
#endif
    float4 m_WorldNormalAndHeight : TEXCOORD_INTERP;
#ifdef FEATURE_TANGENT
    float4 m_WorldTangent  : TEXCOORD_INTERP;
#endif
#ifdef NEED_ATLAS_UVS
    float4 m_Texcoord      : TEXCOORD_INTERP; // regular UVs in xy, atlas UVs in ZW
#else
    float2 m_Texcoord      : TEXCOORD_INTERP; // regular UVs in xy
#endif

#ifdef CLOUDS_NEED_UV
    float2 m_Clouds_TC     : TEXCOORD_INTERP;
#endif
#if !defined(LOW_QUALITY_MODE) || defined(FEATURE_WORLD_POSITION)
    float2 m_WorldPositionXZ : TEXCOORD_INTERP;
#endif
#ifndef DISABLE_SHADOWS
    float3 m_ShadowTC      : TEXCOORD_INTERP; //Dynamic shadow map texture coordinates.
#endif
#ifndef DISABLE_FOW
    float3 m_FoW_TC        : TEXCOORD_INTERP; //Fog of War texture coordinates.
#endif
#ifdef FEATURE_SCREENSPACE_UV
    float4 vScreenSpaceUV : TEXCOORD_INTERP;
#endif
    float3 interp_0 : TEXCOORD_INTERP;
};

float4 Parameter0; // (Vertex_Offset = Parameter0.xyz,Wind_Intensity = Parameter0.w) 
float4 Parameter1; // (Sin_Frequency_Random = Parameter1.xy,Sin_Speed_Random = Parameter1.zw) 
float3 Parameter2; // (Y_Mask_Gradient_Random = Parameter2.xyz) 
float2 Parameter4; // (Y_Mask_Color_Tint = Parameter4.xy) 



/////////////////////////////////////////////////////////////////////////////////////
// Shader
/////////////////////////////////////////////////////////////////////////////////////
INTERPOLANTS main(VERTEX vertex)
{

    INTERPOLANTS interpolants;

    float2 defaultUVs = vertex.m_Texcoord;
    float4 localPosition = float4(vertex.m_Position, 1.0f);
    float3 worldNormal = normalize(mul(float4(vertex.m_Normal,0), WORLD_MATRIX).xyz);

#if defined(FEATURE_VERTEX_COLOR_VS) || defined(FEATURE_VERTEX_COLOR)
    float4 vColorIn0 = vertex.m_Color;
#endif


    float3 var0 = float3(0,0,0); // Float3Literal
    float3 var1;
    { // (LocalPosition)
    float3 result = localPosition.xyz;
    var1 = result;
    }
    float var2 = 1; // FloatLiteral
    float3 var3;
    { // (GrassDistort)
    float3 worldPos = var1;
    float mask = var2
    ;
    float3 offsetWorldPos = worldPos;
    for (int i = 0; i < 10; ++i)
    {
      float4 sphere = GrassDistortSpheres[i];
      float2 dir = worldPos.xz - sphere.xz;
      float l = length(dir);
      float circle = 1 - saturate(l / sphere.w);
      dir *= circle;
      // move sideways
      offsetWorldPos.xz += dir.xy * mask;
      // squish down
      //offsetWorldPos.y -= circle * sphere.w;
    }
    float3 result = offsetWorldPos - worldPos;
    
    var3 = result;
    }
    float3 var4 = float3(0.25,0,0.25); // Float3Literal
    float3 var5 = var3 * var4; // Multiply
    float3 var6 = Parameter0.xyz; // Vertex_Offset
    float var7 = -1; // FloatLiteral
    float3 var8 = var6 * var7; // Multiply
    float2 var9 = Parameter1.xy; // Sin_Frequency_Random
    float var10;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var9.x;
    float y = var9.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var10 = result;
    }
    float2 var11 = Parameter1.zw; // Sin_Speed_Random
    float var12;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var11.x;
    float y = var11.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var12 = result;
    }
    float var13 = 0.1; // FloatLiteral
    float4 var14 = TIME; // Time
    float var15 = var13 * var14.x; // Multiply
    float var16 = var12 * var15; // Multiply
    float2 var17 = float2(-10,10); // Float2Literal
    float3 var18;
    { // (LocalPosition)
    float3 result = localPosition.xyz;
    var18 = result;
    }
    float3 var19 = float3(0,1,0); // Float3Literal
    float var20 = dot(var18,var19); // Dot
    float var21 = smoothstep(var17.x, var17.y, var20); // smoothstep
    float var22 = var16 + var21; // Add
    float2 var23 = float2(1.25,0); // Float2Literal
    float var24;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var23.x;
    float y = var23.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var24 = result;
    }
    float var25 = var22 + var24; // Add
    float var26 = var10 * var25; // Multiply
    float var27 = sin(var26); // sin
    float var28;
    { // (simpleRemap)
    float input = var27;
    float result = ( input + 1 ) * 0.5;
    var28 = result;
    }
    float3 var29 = lerp(var6, var8, var28); // Lerp
    float var30 = Parameter0.w; // Wind_Intensity
    float3 var31 = var29 * var30; // Multiply
    float3 var32 = var5 + var31; // Add
    float3 var33 = Parameter2.xyz; // Y_Mask_Gradient_Random
    float var34;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var33.y;
    float y = var33.z;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var34 = result;
    }
    float3 var35 = float3(0,1,0); // Float3Literal
    float3 var36;
    { // (LocalPosition)
    float3 result = localPosition.xyz;
    var36 = result;
    }
    float var37 = dot(var35,var36); // Dot
    float var38 = smoothstep(var33.x, var34, var37); // smoothstep
    float var39 = saturate(var38); // saturate
    float3 var40 = var32 * var39; // Multiply
    
    #ifdef LOW_QUALITY_MODE
        float3 var41 =  var0;
    #else
        float3 var41 =  var40;
    #endif
    
    
    localPosition.xyz += var41;

    float3 worldPosition = mul(localPosition, WORLD_MATRIX).xyz;
    float3 var42 = float3(0,0,0); // Float3Literal
    float3 var43 = float3(0,25,0); // Float3Literal
    float2 var44 = float2(10,0); // Float2Literal
    float2 var45 = float2(2,5); // Float2Literal
    float2 var46 = float2(1,0); // Float2Literal
    float var47;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var46.x;
    float y = var46.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var47 = result;
    }
    float var48 = lerp(var45.x, var45.y, var47); // Lerp
    float2 var49;
    { // (TransitionFactorAndDirection)
    #ifdef ENV_TRANSITION
    float2 result = TransitionFactorAndDirection;
    #else
    float2 result = float2(0.0f, 0.0f);
    #endif
    
    var49 = result;
    }
    float var50 = var49.x; // Mask
    float var51 = var48 * var50; // Multiply
    float var52 = saturate(var51); // saturate
    float var53 = lerp(var44.x, var44.y, var52); // Lerp
    float var54 = saturate(var53); // saturate
    float3 var55 = lerp(var42, var43, var54); // Lerp
    float3 var56 = float3(0,-300,0); // Float3Literal
    float2 var57 = float2(1,0.5); // Float2Literal
    float var58;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var57.x;
    float y = var57.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var58 = result;
    }
    float3 var59 = var56 * var58; // Multiply
    float3 var60 = float3(0,0,0); // Float3Literal
    float3 var61 = lerp(var59, var60, var52); // Lerp
    float3 var62 = var55 + var61; // Add
    float3 var63 = float3(0,0,0); // Float3Literal
    
    #if ENV_TRANSITION // STATIC_SWITCH: ENV_TRANSITION
        float3 var64 =  var62;
    #else
        float3 var64 =  var63;
    #endif
    
    
    worldPosition.xyz += var64;

    // Output homogeneous position
    interpolants.m_Position = mul(float4(worldPosition, 1.0f), VIEW_PROJECTION_MATRIX);

#ifdef FEATURE_SCREENSPACE_UV
    interpolants.vScreenSpaceUV = interpolants.m_Position.xyzw;
#endif

    interpolants.m_Texcoord.xy = vertex.m_Texcoord;

#if defined(NEED_ATLAS_UVS)
    interpolants.m_Texcoord.zw = vertex.m_AtlasTexcoord;
#endif

    interpolants.m_WorldNormalAndHeight = float4(worldNormal, worldPosition.y);
#if !defined(LOW_QUALITY_MODE) || defined(FEATURE_WORLD_POSITION)
    interpolants.m_WorldPositionXZ = worldPosition.xz;
#endif

#ifdef FEATURE_TANGENT
    float3 worldTangent = normalize(mul(float4(vertex.m_Tangent.xyz,0), WORLD_MATRIX).xyz);
    interpolants.m_WorldTangent = float4(worldTangent, vertex.m_Tangent.w);
#endif

    // Shadow position
#ifndef DISABLE_SHADOWS
    interpolants.m_ShadowTC = mul(float4(worldPosition,1), SHADOW_PROJECTION_MATRIX).xyz;
#endif

#ifndef DISABLE_FOW
        // Fog of war texture coordinates
    #ifdef FOW_FADE_TO_FOGGED
        // the height value we need for fading to fogged is in w, not z
        interpolants.m_FoW_TC = FogOfWarTextureCoordinates( worldPosition ).xyw;
    #else
        interpolants.m_FoW_TC = FogOfWarTextureCoordinates( worldPosition ).xyz;
    #endif
#endif
#ifdef CLOUDS_NEED_UV
     interpolants.m_Clouds_TC = worldPosition.xz * TERRAIN_XFORM.xy + TERRAIN_XFORM.zw;
#endif

#ifdef FEATURE_VERTEX_COLOR
    interpolants.m_VertexColor = vertex.m_Color;
#endif

#ifdef CAPTURE_DIFFUSE
    interpolants.m_Position = float4(vertex.m_AtlasTexcoord * 2.0f - 1.0f, 0.0f, 1.0f);
    DoDX9HalfPixelAdjust(interpolants.m_Position);
#endif

    interpolants.interp_0.x = var27;
    interpolants.interp_0.y = var38;
    float2 var94 = Parameter4.xy; // Y_Mask_Color_Tint
    float var95 = smoothstep(var94.x, var94.y, var37); // smoothstep
    interpolants.interp_0.z = var95;
    
    

    return interpolants;
}
