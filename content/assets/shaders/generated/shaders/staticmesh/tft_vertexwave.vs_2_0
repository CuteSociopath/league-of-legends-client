#include "DATA/Shaders/HLSL/FogOfWar/FogOfWar_VS.hls"
#include "DATA/Shaders/HLSL/DX9HalfPixelAdjust.hls"

#ifdef LOW_QUALITY_MODE
#undef CLOUD_SHADOWS
#endif

#if defined(CLOUD_SHADOWS) && defined(DISABLE_FOW)
#define CLOUDS_NEED_UV 1
#endif

#if !defined(NO_BAKED_LIGHTING) || defined(FEATURE_BAKED_PAINT)
#define NEED_ATLAS_UVS 1
#endif

/////////////////////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////////////////////
column_major float4x4 WORLD_MATRIX;
column_major float4x4 WORLD_MATRIX_INV; // used if particular snippets are used and optimized out if not
float3 MESH_CENTER;

struct VERTEX
{
    float3 m_Position       : X3D_VSIN_POSITION;
    float3 m_Normal         : X3D_VSIN_NORMAL;
    float2 m_Texcoord       : X3D_VSIN_TEXCOORD0;
    
    
#ifdef FEATURE_TANGENT
    float4 m_Tangent : X3D_VSIN_TEXCOORD6;
#endif
    // if the vertex color is used in either the vertex shader or pixel shader
    // we need the input
#if defined(FEATURE_VERTEX_COLOR_VS) || defined(FEATURE_VERTEX_COLOR)
    float4 m_Color : X3D_VSIN_COLOR0;
#endif
#if defined(NEED_ATLAS_UVS) || defined(CAPTURE_DIFFUSE)
    float2 m_AtlasTexcoord  : X3D_VSIN_TEXCOORD7;
#endif
};

struct INTERPOLANTS
{
    float4 m_Position      : POSITION;
    // we only need the interpolant if the vertex color is used in the pixel shader
#ifdef FEATURE_VERTEX_COLOR
    float4 m_VertexColor : COLOR0;
#endif
    float4 m_WorldNormalAndHeight : TEXCOORD_INTERP;
#ifdef FEATURE_TANGENT
    float4 m_WorldTangent  : TEXCOORD_INTERP;
#endif
#ifdef NEED_ATLAS_UVS
    float4 m_Texcoord      : TEXCOORD_INTERP; // regular UVs in xy, atlas UVs in ZW
#else
    float2 m_Texcoord      : TEXCOORD_INTERP; // regular UVs in xy
#endif

#ifdef CLOUDS_NEED_UV
    float2 m_Clouds_TC     : TEXCOORD_INTERP;
#endif
#if !defined(LOW_QUALITY_MODE) || defined(FEATURE_WORLD_POSITION)
    float2 m_WorldPositionXZ : TEXCOORD_INTERP;
#endif
#ifndef DISABLE_SHADOWS
    float3 m_ShadowTC      : TEXCOORD_INTERP; //Dynamic shadow map texture coordinates.
#endif
#ifndef DISABLE_FOW
    float3 m_FoW_TC        : TEXCOORD_INTERP; //Fog of War texture coordinates.
#endif
#ifdef FEATURE_SCREENSPACE_UV
    float4 vScreenSpaceUV : TEXCOORD_INTERP;
#endif
    
};

float4 Parameter0; // (X_Axis_Vertex_Displacement = Parameter0.xyz,X_Axis_UV_Offset_Low = Parameter0.w) 
float4 Parameter1; // (X_Axis_UV_Offset_High = Parameter1.x,X_Axis_UV_Rotation = Parameter1.y,Time_Multiplier_X_Axis = Parameter1.zw) 
float4 Parameter2; // (X_Axis_UV_Offset_Frequency = Parameter2.xy,X_Axis_Offset_UV_Wave = Parameter2.zw) 
float4 Parameter3; // (X_Axis_UV_Mask_Low = Parameter3.x,X_Axis_UV_Mask_High = Parameter3.y,X_UV_Mask_Distance_Offset = Parameter3.z,Y_Axis_UV_Offset_Low = Parameter3.w) 
float4 Parameter4; // (Y_Axis_Vertex_Displacement = Parameter4.xyz,Y_Axis_UV_Offset_High = Parameter4.w) 
float4 Parameter5; // (Y_Axis_UV_Rotation = Parameter5.x,Time_Multiplier_Y_Axis = Parameter5.yz,Y_Axis_UV_Mask_Low = Parameter5.w) 
float4 Parameter6; // (Y_Axis_UV_Offset_Frequency = Parameter6.xy,Y_Axis_Offset_UV_Wave = Parameter6.zw) 
float4 Parameter7; // (Y_Axis_UV_Mask_High = Parameter7.x,Y_UV_Mask_Distance_Offset = Parameter7.y,Z_Axis_UV_Offset_Low = Parameter7.z,Z_Axis_UV_Offset_High = Parameter7.w) 
float4 Parameter8; // (Z_Axis_Vertex_Displacement = Parameter8.xyz,Z_Axis_UV_Rotation = Parameter8.w) 
float4 Parameter9; // (Time_Multiplier_Z_Axis = Parameter9.xy,Z_Axis_UV_Offset_Frequency = Parameter9.zw) 
float4 Parameter10; // (Z_Axis_Offset_UV_Wave = Parameter10.xy,Z_Axis_UV_Mask_Low = Parameter10.z,Z_Axis_UV_Mask_High = Parameter10.w) 
float3 Parameter11; // (Z_UV_Mask_Distance_Offset = Parameter11.x,Wind_Global_Intensity = Parameter11.yz) 



/////////////////////////////////////////////////////////////////////////////////////
// Shader
/////////////////////////////////////////////////////////////////////////////////////
INTERPOLANTS main(VERTEX vertex)
{

    INTERPOLANTS interpolants;

    float2 defaultUVs = vertex.m_Texcoord;
    float4 localPosition = float4(vertex.m_Position, 1.0f);
    float3 worldNormal = normalize(mul(float4(vertex.m_Normal,0), WORLD_MATRIX).xyz);

#if defined(FEATURE_VERTEX_COLOR_VS) || defined(FEATURE_VERTEX_COLOR)
    float4 vColorIn0 = vertex.m_Color;
#endif


    float3 var0 = float3(0,0,0); // Float3Literal
    float3 var1 = Parameter0.xyz; // X_Axis_Vertex_Displacement
    float2 var2;
    { // (Float2Randomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float s = ( factor + 1 ) * 0.5;
    float x = var1.x;
    float y = var1.y;
    float z = var1.z;
    float2 both = float2(x, y);
    float2 value = both * z;
    float2 result = lerp(value, both, s);
    
    
    var2 = result;
    }
    float var3 = var2.x; // Mask
    float var4 = var2.y; // Mask
    float var5 = Parameter0.w; // X_Axis_UV_Offset_Low
    float var6 = Parameter1.x; // X_Axis_UV_Offset_High
    float2 var7;
    { // (UVCoord)
    float2 result = defaultUVs;
    var7 = result;
    }
    float2 var8 = float2(0.5,0.5); // Float2Literal
    float var9 = Parameter1.y; // X_Axis_UV_Rotation
    float2 var10;
    { // (UVRotation)
    float2 uvInput = var7;
    float2 uvPivot = var8;
    float RotAngle = var9 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var10 = result;
    }
    float var11 = var10.x; // Mask
    float var12 = var10.y; // Mask
    
    #if X_AXIS_UV_MASK_DIRECTION_TOGGLE // STATIC_SWITCH: X_AXIS_UV_MASK_DIRECTION_TOGGLE
        float var13 =  var11;
    #else
        float var13 =  var12;
    #endif
    
    float4 var14 = TIME; // Time
    float2 var15 = Parameter1.zw; // Time_Multiplier_X_Axis
    float var16;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var15.x;
    float y = var15.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var16 = result;
    }
    float var17 = var14.x * var16; // Multiply
    float var18 = var13 + var17; // Add
    float2 var19 = Parameter2.xy; // X_Axis_UV_Offset_Frequency
    float var20;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var19.x;
    float y = var19.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var20 = result;
    }
    float var21 = var18 * var20; // Multiply
    float2 var22 = Parameter2.zw; // X_Axis_Offset_UV_Wave
    float var23;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var22.x;
    float y = var22.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var23 = result;
    }
    float var24 = var21 + var23; // Add
    float var25 = sin(var24); // sin
    float var26 = smoothstep(var5, var6, var25); // smoothstep
    float var27 = saturate(var26); // saturate
    float var28 = lerp(var3, var4, var27); // Lerp
    float var29 = Parameter3.x; // X_Axis_UV_Mask_Low
    float var30 = Parameter3.y; // X_Axis_UV_Mask_High
    float var31 = Parameter3.z; // X_UV_Mask_Distance_Offset
    float2 var32;
    { // (UVCoord)
    float2 result = defaultUVs;
    var32 = result;
    }
    float var33 = var32.x; // Mask
    float var34 = var32.y; // Mask
    
    #if X_AXIS_UV_MASK_DIRECTION_TOGGLE // STATIC_SWITCH: X_AXIS_UV_MASK_DIRECTION_TOGGLE
        float var35 =  var33;
    #else
        float var35 =  var34;
    #endif
    
    float var36 = distance(var31,var35); // Distance
    float var37 = smoothstep(var29, var30, var36); // smoothstep
    float var38 = saturate(var37); // saturate
    float var39;
    { // (OneMinus)
    float input =var38;
    float result = 1.0f - input;
    var39 = result;
    }
    
    #if X_AXIS_UV_MASK_DIRECTION_INVERT // STATIC_SWITCH: X_AXIS_UV_MASK_DIRECTION_INVERT
        float var40 =  var39;
    #else
        float var40 =  var38;
    #endif
    
    float var41 = var28 * var40; // Multiply
    
    #if USE_X_AXIS_UV_MASK // STATIC_SWITCH: USE_X_AXIS_UV_MASK
        float var42 =  var41;
    #else
        float var42 =  var28;
    #endif
    
    float var43 = 0; // FloatLiteral
    
    #if USE_X_OFFSET // STATIC_SWITCH: USE_X_OFFSET
        float var44 =  var42;
    #else
        float var44 =  var43;
    #endif
    
    float3 var45 = Parameter4.xyz; // Y_Axis_Vertex_Displacement
    float2 var46;
    { // (Float2Randomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float s = ( factor + 1 ) * 0.5;
    float x = var45.x;
    float y = var45.y;
    float z = var45.z;
    float2 both = float2(x, y);
    float2 value = both * z;
    float2 result = lerp(value, both, s);
    
    
    var46 = result;
    }
    float var47 = var46.x; // Mask
    float var48 = var46.y; // Mask
    float var49 = Parameter3.w; // Y_Axis_UV_Offset_Low
    float var50 = Parameter4.w; // Y_Axis_UV_Offset_High
    float2 var51;
    { // (UVCoord)
    float2 result = defaultUVs;
    var51 = result;
    }
    float2 var52 = float2(0.5,0.5); // Float2Literal
    float var53 = Parameter5.x; // Y_Axis_UV_Rotation
    float2 var54;
    { // (UVRotation)
    float2 uvInput = var51;
    float2 uvPivot = var52;
    float RotAngle = var53 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var54 = result;
    }
    float var55 = var54.x; // Mask
    float var56 = var54.y; // Mask
    
    #if Y_AXIS_UV_MASK_DIRECTION_TOGGLE // STATIC_SWITCH: Y_AXIS_UV_MASK_DIRECTION_TOGGLE
        float var57 =  var55;
    #else
        float var57 =  var56;
    #endif
    
    float4 var58 = TIME; // Time
    float2 var59 = Parameter5.yz; // Time_Multiplier_Y_Axis
    float var60;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var59.x;
    float y = var59.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var60 = result;
    }
    float var61 = var58.x * var60; // Multiply
    float var62 = var57 + var61; // Add
    float2 var63 = Parameter6.xy; // Y_Axis_UV_Offset_Frequency
    float var64;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var63.x;
    float y = var63.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var64 = result;
    }
    float var65 = var62 * var64; // Multiply
    float2 var66 = Parameter6.zw; // Y_Axis_Offset_UV_Wave
    float var67;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var66.x;
    float y = var66.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var67 = result;
    }
    float var68 = var65 + var67; // Add
    float var69 = sin(var68); // sin
    float var70 = smoothstep(var49, var50, var69); // smoothstep
    float var71 = saturate(var70); // saturate
    float var72 = lerp(var47, var48, var71); // Lerp
    float var73 = Parameter5.w; // Y_Axis_UV_Mask_Low
    float var74 = Parameter7.x; // Y_Axis_UV_Mask_High
    float var75 = Parameter7.y; // Y_UV_Mask_Distance_Offset
    float2 var76;
    { // (UVCoord)
    float2 result = defaultUVs;
    var76 = result;
    }
    float var77 = var76.x; // Mask
    float var78 = var76.y; // Mask
    
    #if Y_AXIS_UV_MASK_DIRECTION_TOGGLE // STATIC_SWITCH: Y_AXIS_UV_MASK_DIRECTION_TOGGLE
        float var79 =  var77;
    #else
        float var79 =  var78;
    #endif
    
    float var80 = distance(var75,var79); // Distance
    float var81 = smoothstep(var73, var74, var80); // smoothstep
    float var82 = saturate(var81); // saturate
    float var83;
    { // (OneMinus)
    float input =var82;
    float result = 1.0f - input;
    var83 = result;
    }
    
    #if Y_AXIS_UV_MASK_DIRECTION_INVERT // STATIC_SWITCH: Y_AXIS_UV_MASK_DIRECTION_INVERT
        float var84 =  var83;
    #else
        float var84 =  var82;
    #endif
    
    float var85 = var72 * var84; // Multiply
    
    #if USE_Y_AXIS_UV_MASK // STATIC_SWITCH: USE_Y_AXIS_UV_MASK
        float var86 =  var85;
    #else
        float var86 =  var72;
    #endif
    
    float var87 = 0; // FloatLiteral
    
    #if USE_Y_OFFSET // STATIC_SWITCH: USE_Y_OFFSET
        float var88 =  var86;
    #else
        float var88 =  var87;
    #endif
    
    float2 var89 = float2(var44,var88); // Combine
    float3 var90 = Parameter8.xyz; // Z_Axis_Vertex_Displacement
    float2 var91;
    { // (Float2Randomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float s = ( factor + 1 ) * 0.5;
    float x = var90.x;
    float y = var90.y;
    float z = var90.z;
    float2 both = float2(x, y);
    float2 value = both * z;
    float2 result = lerp(value, both, s);
    
    
    var91 = result;
    }
    float var92 = var91.x; // Mask
    float var93 = var91.y; // Mask
    float var94 = Parameter7.z; // Z_Axis_UV_Offset_Low
    float var95 = Parameter7.w; // Z_Axis_UV_Offset_High
    float2 var96;
    { // (UVCoord)
    float2 result = defaultUVs;
    var96 = result;
    }
    float2 var97 = float2(0.5,0.5); // Float2Literal
    float var98 = Parameter8.w; // Z_Axis_UV_Rotation
    float2 var99;
    { // (UVRotation)
    float2 uvInput = var96;
    float2 uvPivot = var97;
    float RotAngle = var98 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var99 = result;
    }
    float var100 = var99.x; // Mask
    float var101 = var99.y; // Mask
    
    #if Z_AXIS_UV_MASK_DIRECTION_TOGGLE // STATIC_SWITCH: Z_AXIS_UV_MASK_DIRECTION_TOGGLE
        float var102 =  var100;
    #else
        float var102 =  var101;
    #endif
    
    float4 var103 = TIME; // Time
    float2 var104 = Parameter9.xy; // Time_Multiplier_Z_Axis
    float var105;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var104.x;
    float y = var104.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var105 = result;
    }
    float var106 = var103.x * var105; // Multiply
    float var107 = var102 + var106; // Add
    float2 var108 = Parameter9.zw; // Z_Axis_UV_Offset_Frequency
    float var109;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var108.x;
    float y = var108.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var109 = result;
    }
    float var110 = var107 * var109; // Multiply
    float2 var111 = Parameter10.xy; // Z_Axis_Offset_UV_Wave
    float var112;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var111.x;
    float y = var111.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var112 = result;
    }
    float var113 = var110 + var112; // Add
    float var114 = sin(var113); // sin
    float var115 = smoothstep(var94, var95, var114); // smoothstep
    float var116 = saturate(var115); // saturate
    float var117 = lerp(var92, var93, var116); // Lerp
    float var118 = Parameter10.z; // Z_Axis_UV_Mask_Low
    float var119 = Parameter10.w; // Z_Axis_UV_Mask_High
    float var120 = Parameter11.x; // Z_UV_Mask_Distance_Offset
    float2 var121;
    { // (UVCoord)
    float2 result = defaultUVs;
    var121 = result;
    }
    float var122 = var121.x; // Mask
    float var123 = var121.y; // Mask
    
    #if Z_AXIS_UV_MASK_DIRECTION_TOGGLE // STATIC_SWITCH: Z_AXIS_UV_MASK_DIRECTION_TOGGLE
        float var124 =  var122;
    #else
        float var124 =  var123;
    #endif
    
    float var125 = distance(var120,var124); // Distance
    float var126 = smoothstep(var118, var119, var125); // smoothstep
    float var127 = saturate(var126); // saturate
    float var128;
    { // (OneMinus)
    float input =var127;
    float result = 1.0f - input;
    var128 = result;
    }
    
    #if Z_AXIS_UV_MASK_DIRECTION_INVERT // STATIC_SWITCH: Z_AXIS_UV_MASK_DIRECTION_INVERT
        float var129 =  var128;
    #else
        float var129 =  var127;
    #endif
    
    float var130 = var117 * var129; // Multiply
    
    #if USE_Z_AXIS_UV_MASK // STATIC_SWITCH: USE_Z_AXIS_UV_MASK
        float var131 =  var130;
    #else
        float var131 =  var117;
    #endif
    
    float var132 = 0; // FloatLiteral
    
    #if USE_Z_OFFSET // STATIC_SWITCH: USE_Z_OFFSET
        float var133 =  var131;
    #else
        float var133 =  var132;
    #endif
    
    float3 var134 = float3(var89.xy,var133); // Combine
    float2 var135 = Parameter11.yz; // Wind_Global_Intensity
    float var136;
    { // (FloatRandomize)
    float3 mLoc = MESH_CENTER;
    float factor = sin(mLoc.x + mLoc.y + mLoc.z);
    float t = ( factor + 1 ) * 0.5;
    float x = var135.x;
    float y = var135.y;
    float value = x * y;
    float result = lerp(x, value,  t);
    
    
    var136 = result;
    }
    float3 var137 = lerp(var0, var134, var136); // Lerp
    
    localPosition.xyz += var137;

    float3 worldPosition = mul(localPosition, WORLD_MATRIX).xyz;
    
    worldPosition.xyz +=  float3(0,0,0) ;

    // Output homogeneous position
    interpolants.m_Position = mul(float4(worldPosition, 1.0f), VIEW_PROJECTION_MATRIX);

#ifdef FEATURE_SCREENSPACE_UV
    interpolants.vScreenSpaceUV = interpolants.m_Position.xyzw;
#endif

    interpolants.m_Texcoord.xy = vertex.m_Texcoord;

#if defined(NEED_ATLAS_UVS)
    interpolants.m_Texcoord.zw = vertex.m_AtlasTexcoord;
#endif

    interpolants.m_WorldNormalAndHeight = float4(worldNormal, worldPosition.y);
#if !defined(LOW_QUALITY_MODE) || defined(FEATURE_WORLD_POSITION)
    interpolants.m_WorldPositionXZ = worldPosition.xz;
#endif

#ifdef FEATURE_TANGENT
    float3 worldTangent = normalize(mul(float4(vertex.m_Tangent.xyz,0), WORLD_MATRIX).xyz);
    interpolants.m_WorldTangent = float4(worldTangent, vertex.m_Tangent.w);
#endif

    // Shadow position
#ifndef DISABLE_SHADOWS
    interpolants.m_ShadowTC = mul(float4(worldPosition,1), SHADOW_PROJECTION_MATRIX).xyz;
#endif

#ifndef DISABLE_FOW
        // Fog of war texture coordinates
    #ifdef FOW_FADE_TO_FOGGED
        // the height value we need for fading to fogged is in w, not z
        interpolants.m_FoW_TC = FogOfWarTextureCoordinates( worldPosition ).xyw;
    #else
        interpolants.m_FoW_TC = FogOfWarTextureCoordinates( worldPosition ).xyz;
    #endif
#endif
#ifdef CLOUDS_NEED_UV
     interpolants.m_Clouds_TC = worldPosition.xz * TERRAIN_XFORM.xy + TERRAIN_XFORM.zw;
#endif

#ifdef FEATURE_VERTEX_COLOR
    interpolants.m_VertexColor = vertex.m_Color;
#endif

#ifdef CAPTURE_DIFFUSE
    interpolants.m_Position = float4(vertex.m_AtlasTexcoord * 2.0f - 1.0f, 0.0f, 1.0f);
    DoDX9HalfPixelAdjust(interpolants.m_Position);
#endif

    
    

    return interpolants;
}
