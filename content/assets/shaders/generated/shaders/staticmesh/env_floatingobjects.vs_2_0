#include "DATA/Shaders/HLSL/FogOfWar/FogOfWar_VS.hls"
#include "DATA/Shaders/HLSL/DX9HalfPixelAdjust.hls"

#ifdef LOW_QUALITY_MODE
#undef CLOUD_SHADOWS
#endif

#if defined(CLOUD_SHADOWS) && defined(DISABLE_FOW)
#define CLOUDS_NEED_UV 1
#endif

#if !defined(NO_BAKED_LIGHTING) || defined(FEATURE_BAKED_PAINT)
#define NEED_ATLAS_UVS 1
#endif

/////////////////////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////////////////////
column_major float4x4 WORLD_MATRIX;
column_major float4x4 WORLD_MATRIX_INV; // used if particular snippets are used and optimized out if not
float3 MESH_CENTER;

struct VERTEX
{
    float3 m_Position       : X3D_VSIN_POSITION;
    float3 m_Normal         : X3D_VSIN_NORMAL;
    float2 m_Texcoord       : X3D_VSIN_TEXCOORD0;
    
    
#ifdef FEATURE_TANGENT
    float4 m_Tangent : X3D_VSIN_TEXCOORD6;
#endif
    // if the vertex color is used in either the vertex shader or pixel shader
    // we need the input
#if defined(FEATURE_VERTEX_COLOR_VS) || defined(FEATURE_VERTEX_COLOR)
    float4 m_Color : X3D_VSIN_COLOR0;
#endif
#if defined(NEED_ATLAS_UVS) || defined(CAPTURE_DIFFUSE)
    float2 m_AtlasTexcoord  : X3D_VSIN_TEXCOORD7;
#endif
};

struct INTERPOLANTS
{
    float4 m_Position      : POSITION;
    // we only need the interpolant if the vertex color is used in the pixel shader
#ifdef FEATURE_VERTEX_COLOR
    float4 m_VertexColor : COLOR0;
#endif
    float4 m_WorldNormalAndHeight : TEXCOORD_INTERP;
#ifdef FEATURE_TANGENT
    float4 m_WorldTangent  : TEXCOORD_INTERP;
#endif
#ifdef NEED_ATLAS_UVS
    float4 m_Texcoord      : TEXCOORD_INTERP; // regular UVs in xy, atlas UVs in ZW
#else
    float2 m_Texcoord      : TEXCOORD_INTERP; // regular UVs in xy
#endif

#ifdef CLOUDS_NEED_UV
    float2 m_Clouds_TC     : TEXCOORD_INTERP;
#endif
#if !defined(LOW_QUALITY_MODE) || defined(FEATURE_WORLD_POSITION)
    float2 m_WorldPositionXZ : TEXCOORD_INTERP;
#endif
#ifndef DISABLE_SHADOWS
    float3 m_ShadowTC      : TEXCOORD_INTERP; //Dynamic shadow map texture coordinates.
#endif
#ifndef DISABLE_FOW
    float3 m_FoW_TC        : TEXCOORD_INTERP; //Fog of War texture coordinates.
#endif
#ifdef FEATURE_SCREENSPACE_UV
    float4 vScreenSpaceUV : TEXCOORD_INTERP;
#endif
    
};

float4 Parameter0; // (Translate_Axis = Parameter0.xyz,Bobbing_Rate = Parameter0.w) 
float4 Parameter1; // (Translate_Range = Parameter1.xy,RotationAngle_Primary = Parameter1.zw) 
float4 Parameter2; // (RotationalAxis_Primary = Parameter2.xyz,Secondary_Rotation_Rate = Parameter2.w) 
float3 Parameter3; // (RotationalAxis_Secondary = Parameter3.xyz) 
float2 Parameter4; // (RotationAngle_Secondary = Parameter4.xy) 



/////////////////////////////////////////////////////////////////////////////////////
// Shader
/////////////////////////////////////////////////////////////////////////////////////
INTERPOLANTS main(VERTEX vertex)
{

    INTERPOLANTS interpolants;

    float2 defaultUVs = vertex.m_Texcoord;
    float4 localPosition = float4(vertex.m_Position, 1.0f);
    float3 worldNormal = normalize(mul(float4(vertex.m_Normal,0), WORLD_MATRIX).xyz);

#if defined(FEATURE_VERTEX_COLOR_VS) || defined(FEATURE_VERTEX_COLOR)
    float4 vColorIn0 = vertex.m_Color;
#endif


    
    localPosition.xyz +=  float3(0,0,0) ;

    float3 worldPosition = mul(localPosition, WORLD_MATRIX).xyz;
    float3 var0 = Parameter0.xyz; // Translate_Axis
    float3 var1 = normalize(var0); // normalize
    float2 var2 = Parameter1.xy; // Translate_Range
    float4 var3 = TIME; // Time
    float var4;
    { // (RandomizeByLocation)
    float3 mLoc = MESH_CENTER;
    float result = sin(mLoc.x + mLoc.y + mLoc.z);
    var4 = result;
    }
    float var5 = var3.x + var4; // Add
    float var6 = Parameter0.w; // Bobbing_Rate
    float var7 = 0.5; // FloatLiteral
    float var8;
    { // (SineFunctionComplete)
    float Time = var5;
    float Freq = var6;
    float Amp = var7;
    float Offset = var7;
    float result = sin( Time * Freq ) * Amp + Offset;
    var8 = result;
    }
    float var9 = lerp(var2.x, var2.y, var8); // Lerp
    float3 var10 = var1 * var9; // Multiply
    float3 var11 = Parameter2.xyz; // RotationalAxis_Primary
    float2 var12 = Parameter1.zw; // RotationAngle_Primary
    float var13 = 0.5; // FloatLiteral
    float var14 = var5 + var13; // Add
    float var15;
    { // (SineFunctionComplete)
    float Time = var14;
    float Freq = var6;
    float Amp = var7;
    float Offset = var7;
    float result = sin( Time * Freq ) * Amp + Offset;
    var15 = result;
    }
    float var16 = lerp(var12.x, var12.y, var15); // Lerp
    float3 var17;
    { // (MeshCenter)
    float3 result = MESH_CENTER;
    var17 = result;
    }
    float3 var18;
    { // (WorldPosition)
    float3 result = worldPosition;
    var18 = result;
    }
    float3 var19;
    { // (RotateAboutAxis)
    float PI = 3.14159265f;
    float3 NormalizedRotationAxis = var11;
    float Angle = var16;
    Angle = Angle * (2.0f * PI / 1.0);
    float4 NormalizedRotationAxisAndAngle = float4( NormalizedRotationAxis, Angle );
    
    float3 PositionOnAxis = var17;
    float3 Position = var18;
    
    // Project Position onto the rotation axis and find the closest point on the axis to Position
    	float3 ClosestPointOnAxis = PositionOnAxis + NormalizedRotationAxisAndAngle.xyz * dot(NormalizedRotationAxisAndAngle.xyz, Position - PositionOnAxis);
    // Construct orthogonal axes in the plane of the rotation
    	float3 UAxis = Position - ClosestPointOnAxis;
    	float3 VAxis = cross(NormalizedRotationAxisAndAngle.xyz, UAxis);
    	float CosAngle;
    	float SinAngle;
    	sincos(NormalizedRotationAxisAndAngle.w, SinAngle, CosAngle);
    // Rotate using the orthogonal axes
    	float3 R = UAxis * CosAngle + VAxis * SinAngle;
    // Reconstruct the rotated world space position
    	float3 RotatedPosition = ClosestPointOnAxis + R;
    // Convert from position to a position offset
    	float3 result = RotatedPosition - Position;
    var19 = result;
    }
    float3 var20 = Parameter3.xyz; // RotationalAxis_Secondary
    float2 var21 = Parameter4.xy; // RotationAngle_Secondary
    float var22 = Parameter2.w; // Secondary_Rotation_Rate
    float var23 = var5 * var22; // Multiply
    float var24 = var6 * var23; // Multiply
    float var25;
    { // (SimpleNoise)
    float x = var24;
    float amp = var7;
    float offset = var7;
    float noise = cos(2*x+1.7)*cos(3.3*x)*sin(.8*x);
    float result = noise * amp + offset;
    var25 = result;
    }
    float var26 = var6 * var22; // Multiply
    float var27;
    { // (SineFunctionComplete)
    float Time = var14;
    float Freq = var26;
    float Amp = var7;
    float Offset = var7;
    float result = sin( Time * Freq ) * Amp + Offset;
    var27 = result;
    }
    
    #if USE_RANDOM_SECONDARY_MOTION // STATIC_SWITCH: USE_RANDOM_SECONDARY_MOTION
        float var28 =  var25;
    #else
        float var28 =  var27;
    #endif
    
    float var29 = lerp(var21.x, var21.y, var28); // Lerp
    float3 var30 = var19 + var18; // Add
    float3 var31;
    { // (RotateAboutAxis)
    float PI = 3.14159265f;
    float3 NormalizedRotationAxis = var20;
    float Angle = var29;
    Angle = Angle * (2.0f * PI / 1.0);
    float4 NormalizedRotationAxisAndAngle = float4( NormalizedRotationAxis, Angle );
    
    float3 PositionOnAxis = var17;
    float3 Position = var30;
    
    // Project Position onto the rotation axis and find the closest point on the axis to Position
    	float3 ClosestPointOnAxis = PositionOnAxis + NormalizedRotationAxisAndAngle.xyz * dot(NormalizedRotationAxisAndAngle.xyz, Position - PositionOnAxis);
    // Construct orthogonal axes in the plane of the rotation
    	float3 UAxis = Position - ClosestPointOnAxis;
    	float3 VAxis = cross(NormalizedRotationAxisAndAngle.xyz, UAxis);
    	float CosAngle;
    	float SinAngle;
    	sincos(NormalizedRotationAxisAndAngle.w, SinAngle, CosAngle);
    // Rotate using the orthogonal axes
    	float3 R = UAxis * CosAngle + VAxis * SinAngle;
    // Reconstruct the rotated world space position
    	float3 RotatedPosition = ClosestPointOnAxis + R;
    // Convert from position to a position offset
    	float3 result = RotatedPosition - Position;
    var31 = result;
    }
    float3 var32 = var19 + var31; // Add
    float3 var33 = var10 + var32; // Add
    
    #ifdef LOW_QUALITY_MODE
        float3 var34 =  var10;
    #else
        float3 var34 =  var33;
    #endif
    
    
    worldPosition.xyz += var34;

    // Output homogeneous position
    interpolants.m_Position = mul(float4(worldPosition, 1.0f), VIEW_PROJECTION_MATRIX);

#ifdef FEATURE_SCREENSPACE_UV
    interpolants.vScreenSpaceUV = interpolants.m_Position.xyzw;
#endif

    interpolants.m_Texcoord.xy = vertex.m_Texcoord;

#if defined(NEED_ATLAS_UVS)
    interpolants.m_Texcoord.zw = vertex.m_AtlasTexcoord;
#endif

    interpolants.m_WorldNormalAndHeight = float4(worldNormal, worldPosition.y);
#if !defined(LOW_QUALITY_MODE) || defined(FEATURE_WORLD_POSITION)
    interpolants.m_WorldPositionXZ = worldPosition.xz;
#endif

#ifdef FEATURE_TANGENT
    float3 worldTangent = normalize(mul(float4(vertex.m_Tangent.xyz,0), WORLD_MATRIX).xyz);
    interpolants.m_WorldTangent = float4(worldTangent, vertex.m_Tangent.w);
#endif

    // Shadow position
#ifndef DISABLE_SHADOWS
    interpolants.m_ShadowTC = mul(float4(worldPosition,1), SHADOW_PROJECTION_MATRIX).xyz;
#endif

#ifndef DISABLE_FOW
        // Fog of war texture coordinates
    #ifdef FOW_FADE_TO_FOGGED
        // the height value we need for fading to fogged is in w, not z
        interpolants.m_FoW_TC = FogOfWarTextureCoordinates( worldPosition ).xyw;
    #else
        interpolants.m_FoW_TC = FogOfWarTextureCoordinates( worldPosition ).xyz;
    #endif
#endif
#ifdef CLOUDS_NEED_UV
     interpolants.m_Clouds_TC = worldPosition.xz * TERRAIN_XFORM.xy + TERRAIN_XFORM.zw;
#endif

#ifdef FEATURE_VERTEX_COLOR
    interpolants.m_VertexColor = vertex.m_Color;
#endif

#ifdef CAPTURE_DIFFUSE
    interpolants.m_Position = float4(vertex.m_AtlasTexcoord * 2.0f - 1.0f, 0.0f, 1.0f);
    DoDX9HalfPixelAdjust(interpolants.m_Position);
#endif

    
    

    return interpolants;
}
