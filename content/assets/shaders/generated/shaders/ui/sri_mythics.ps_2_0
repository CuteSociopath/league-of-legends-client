float4 Parameter0; // (Global_Mask_SmoothStep = Parameter0.xy,Scanline_SmoothStep = Parameter0.zw) 
float4 Parameter1; // (Scanline_Noise_MinMax = Parameter1.xy,Scanline_Noise_Tile = Parameter1.zw) 
float4 Parameter2; // (Scanline_Angle = Parameter2.x,Scanline_Noise_Speed = Parameter2.yz,Scanline_Speed = Parameter2.w) 
float4 Parameter3; // (Scanline_Frequency = Parameter3.x,Rect_Mask_SmoothStep = Parameter3.yz,Rect_Mask_Offset = Parameter3.w) 
float4 Parameter4; // (Radial_Noise_SmoothStep = Parameter4.xy,Radial_Noise_MinMax = Parameter4.zw) 
float4 Parameter5; // (PinWheel_Noise_Tile = Parameter5.xy,Radial_Noise_Offset = Parameter5.zw) 
float4 Parameter6; // (Radial_Noise_Frequency = Parameter6.x,Linear_SmoothStep = Parameter6.yz,Linear_Angle = Parameter6.w) 
float4 Parameter7; // (Linear_Offset = Parameter7.x,Linear_Factor = Parameter7.y,Radial_SmoothStep = Parameter7.zw) 
float4 Parameter8; // (Radial_MaskOffset = Parameter8.xy,Radial_MaskSize = Parameter8.z,PinWheel_Segments = Parameter8.w) 
float4 Parameter9; // (PinWheel_SmoothStep = Parameter9.xy,PinWheel_Center = Parameter9.zw) 
float4 Parameter10; // (PinWheelNoise_MinMax = Parameter10.xy,PinWheelNoise_Speed = Parameter10.zw) 
float4 Parameter11; // (Scale_MinMax = Parameter11.xy,Scale_Speed = Parameter11.z,UV_Background_Zoom = Parameter11.w) 
float4 Parameter12; // (Scale_Center = Parameter12.xy,UV_Distortion_MinMax = Parameter12.zw) 
float4 Parameter13; // (RefractionNoise_Distance = Parameter13.x,RefractionNoiseSize = Parameter13.y,Blue_Channel_BG_Offset = Parameter13.z,Radial_Noise_Rotation = Parameter13.w) 
float4 Parameter14; // (BG_FlatColor = Parameter14.xyzw) 
float4 Parameter15; // (BGColor_A = Parameter15.xyzw) 
float4 Parameter16; // (BGColor_B = Parameter16.xyzw) 
float4 Parameter17; // (Background_MinMax = Parameter17.xy,Foreground_MinMax = Parameter17.zw) 
float4 Parameter18; // (FG_Color_A = Parameter18.xyzw) 
sampler2D Noise_Texture;
sampler2D Mask_Texture;


struct INTERPOLANTS
{
    float4 position       : POSITION;
    float4 perVertexColor : COLOR0;
    float2 tex0           : TEXCOORD_INTERP;
#ifdef FEATURE_UI_USER_PARAMS
    float4 userParamsInterp: TEXCOORD_INTERP;
#endif
// this define gets enabled if the user uses the UI Original Texcoords snippet
#ifdef FEATURE_UI_ORIGINAL_TEXCOORDS
    float2 orginalTexCoords: TEXCOORD_INTERP;
#endif

    float4 interp_0 : TEXCOORD_INTERP;
};

float4 main(INTERPOLANTS interpolants) : COLOR0
{

// this define gets defined if the shader author uses the UI Parameters snippet
#ifdef FEATURE_UI_USER_PARAMS
    float4 UIUserParams = interpolants.userParamsInterp;
#endif

#ifdef FEATURE_UI_ORIGINAL_TEXCOORDS
    float2 orginalTexCoords = interpolants.orginalTexCoords;
#endif

    float2 defaultUVs = interpolants.tex0;
    float4 var0;
    { // (UIPrimaryTexture)
    float2 uvs = defaultUVs ;
    
    float4 result = tex2D(UI_PRIMARY_TEXTURE, uvs);
    var0 = result;
    }
    float2 var1 = Parameter0.xy; // Global_Mask_SmoothStep
    float2 var2 = Parameter0.zw; // Scanline_SmoothStep
    float2 var3 = Parameter1.xy; // Scanline_Noise_MinMax
    float2 var4 = Parameter1.zw; // Scanline_Noise_Tile
    float2 var5;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var5 = result;
    }
    float2 var6 = float2(0.5,0.5); // Float2Literal
    float var7 = Parameter2.x; // Scanline_Angle
    float var8 = 3.141592741; // pi
    float var9 = 180; // FloatLiteral
    float var10 = var8 / var9; // Divide
    float var11 = var7 * var10; // Multiply
    float2 var12;
    { // (UVRotation)
    float2 uvInput = var5;
    float2 uvPivot = var6;
    float RotAngle = var11 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var12 = result;
    }
    
    #if SCANLINE_ROTATE_NOISE // STATIC_SWITCH: SCANLINE_ROTATE_NOISE
        float2 var13 =  var12;
    #else
        float2 var13 =  var5;
    #endif
    
    float4 var14 = TIME; // Time
    float2 var15 = Parameter2.yz; // Scanline_Noise_Speed
    float2 var16;
    { // (Panner)
    float2 uvInput = var13;
    float time = var14.x;
    float2 speed = var15;
    float2 scroll = float2( ( time * speed.x + uvInput.x ), ( time * speed.y + uvInput.y ));
    float2 result = scroll;
    var16 = result;
    }
    float2 var17 = var4 * var16; // Multiply
    float4 var18 = tex2D(Noise_Texture, var17); // Noise_Texture
    float var19 = lerp(var3.x, var3.y, var18.x); // Lerp
    float2 var20;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var20 = result;
    }
    float2 var21;
    { // (UVRotation)
    float2 uvInput = var20;
    float2 uvPivot = var6;
    float RotAngle = var11 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var21 = result;
    }
    float var22 = var21.x; // Mask
    float var23 = var19 + var22; // Add
    
    #if USE_SCANLINE_NOISE // STATIC_SWITCH: USE_SCANLINE_NOISE
        float var24 =  var23;
    #else
        float var24 =  var22;
    #endif
    
    float4 var25 = TIME; // Time
    float var26 = Parameter2.w; // Scanline_Speed
    float var27 = var25.x * var26; // Multiply
    float var28 = var24 + var27; // Add
    float var29 = Parameter3.x; // Scanline_Frequency
    float var30 = var28 * var29; // Multiply
    float var31 = sin(var30); // sin
    float var32;
    { // (simpleRemap)
    float input = var31;
    float result = ( input + 1 ) * 0.5;
    var32 = result;
    }
    float var33 = smoothstep(var2.x, var2.y, var32); // smoothstep
    float var34 = saturate(var33); // saturate
    float2 var35 = Parameter3.yz; // Rect_Mask_SmoothStep
    float var36 = -1; // FloatLiteral
    float var37 = 1; // FloatLiteral
    float var38 = Parameter3.w; // Rect_Mask_Offset
    float var39 = var37 + var38; // Add
    float var40 = var36 * var39; // Multiply
    float2 var41 = float2(var40,var40); // Splat
    float2 var42;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var42 = result;
    }
    float2 var43 = var41 + var42; // Add
    float var44 = 18; // FloatLiteral
    float2 var45 = pow(var43,var44); // Pow
    float var46 = var45.x; // Mask
    float var47 = var45.y; // Mask
    float var48 = max(var46,var47); // max
    float var49 = 1; // FloatLiteral
    float var50 = var39 - var49; // Subtract
    float2 var51 = float2(var50,var50); // Splat
    float2 var52 = var42 + var51; // Add
    float2 var53 = pow(var52,var44); // Pow
    float var54 = var53.x; // Mask
    float var55 = var53.y; // Mask
    float var56 = max(var54,var55); // max
    float var57 = max(var48,var56); // max
    float var58 = saturate(var57); // saturate
    float var59 = smoothstep(var35.x, var35.y, var58); // smoothstep
    float2 var60 = Parameter4.xy; // Radial_Noise_SmoothStep
    float2 var61 = Parameter4.zw; // Radial_Noise_MinMax
    float2 var62;
    { // (UVCoord)
    float2 result = defaultUVs;
    var62 = result;
    }
    float2 var63 = Parameter5.xy; // PinWheel_Noise_Tile
    float2 var64 = var62 * var63; // Multiply
    float2 var65 = float2(0.5,0.5); // Float2Literal
    float var66 = interpolants.interp_0.x; // EvaluateInVertexShader
    float2 var67;
    { // (UVRotation)
    float2 uvInput = var64;
    float2 uvPivot = var65;
    float RotAngle = var66 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var67 = result;
    }
    float4 var68 = tex2D(Noise_Texture, var67); // Noise_Texture
    float4 var69 = tex2D(Noise_Texture, defaultUVs); // Noise_Texture
    float var70 = max(var68.y,var69.x); // max
    
    #if RADIAL_NOISE_COMBINE // STATIC_SWITCH: RADIAL_NOISE_COMBINE
        float var71 =  var70;
    #else
        float var71 =  var68.y;
    #endif
    
    float var72 = lerp(var61.x, var61.y, var71); // Lerp
    float2 var73 = Parameter5.zw; // Radial_Noise_Offset
    float2 var74;
    { // (UVCoord)
    float2 result = defaultUVs;
    var74 = result;
    }
    float2 var75 = var73 - var74; // Subtract
    float var76 = length(var75); // length
    float var77 = interpolants.interp_0.y; // EvaluateInVertexShader
    float var78 = var76 + var77; // Add
    float var79 = var72 + var78; // Add
    
    #if USE_RADIAL_NOISE // STATIC_SWITCH: USE_RADIAL_NOISE
        float var80 =  var79;
    #else
        float var80 =  var78;
    #endif
    
    float var81 = Parameter6.x; // Radial_Noise_Frequency
    float var82 = var80 * var81; // Multiply
    float var83 = sin(var82); // sin
    float var84;
    { // (simpleRemap)
    float input = var83;
    float result = ( input + 1 ) * 0.5;
    var84 = result;
    }
    float var85 = smoothstep(var60.x, var60.y, var84); // smoothstep
    float var86 = 1; // FloatLiteral
    
    #if USE_RADIALNOISE_MASK // STATIC_SWITCH: USE_RADIALNOISE_MASK
        float var87 =  var85;
    #else
        float var87 =  var86;
    #endif
    
    float2 var88 = Parameter6.yz; // Linear_SmoothStep
    float2 var89;
    { // (UVCoord)
    float2 result = defaultUVs;
    var89 = result;
    }
    float2 var90 = float2(0.5,0.5); // Float2Literal
    float var91 = Parameter6.w; // Linear_Angle
    float var92 = 3.141592741; // pi
    float var93 = 180; // FloatLiteral
    float var94 = var92 / var93; // Divide
    float var95 = var91 * var94; // Multiply
    float2 var96;
    { // (UVRotation)
    float2 uvInput = var89;
    float2 uvPivot = var90;
    float RotAngle = var95 * -1.0;
    float SinRot = sin(RotAngle);
    float CosRot = cos(RotAngle);
    float2 UVCenter = ( uvPivot * -1) + uvInput;
    float xDot = dot( UVCenter, float2( CosRot, ( SinRot * -1.0 ) ) );
    float yDot = dot( UVCenter, float2( SinRot, CosRot ) );
    float2 UVRot = float2( xDot, yDot );
    float2 result =  uvPivot + UVRot;
    var96 = result;
    }
    float var97 = var96.x; // Mask
    float var98 = Parameter7.x; // Linear_Offset
    float var99 = var97 + var98; // Add
    float var100;
    { // (OneMinus)
    float input =var99;
    float result = 1.0f - input;
    var100 = result;
    }
    float var101 = var100 * var99; // Multiply
    
    #if MIRROR_LINEAR_MASK // STATIC_SWITCH: MIRROR_LINEAR_MASK
        float var102 =  var101;
    #else
        float var102 =  var99;
    #endif
    
    float var103 = Parameter7.y; // Linear_Factor
    float var104 = var102 * var103; // Multiply
    float var105 = saturate(var104); // saturate
    float var106 = smoothstep(var88.x, var88.y, var105); // smoothstep
    
    #if USE_LINEAR_MASK // STATIC_SWITCH: USE_LINEAR_MASK
        float var107 =  var106;
    #else
        float var107 =  var86;
    #endif
    
    float2 var108 = Parameter7.zw; // Radial_SmoothStep
    float2 var109 = Parameter8.xy; // Radial_MaskOffset
    float2 var110;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var110 = result;
    }
    float2 var111 = var109 + var110; // Add
    float2 var112;
    { // (simpleRemapFloat2)
    float2 input = var111;
    float2 result = float2(input.x*2-1, input.y*2-1);
    var112 = result;
    }
    float var113 = Parameter8.z; // Radial_MaskSize
    float2 var114 = var112 * var113; // Multiply
    float var115 = length(var114); // length
    float var116;
    { // (OneMinus)
    float input =var115;
    float result = 1.0f - input;
    var116 = result;
    }
    float var117 = smoothstep(var108.x, var108.y, var116); // smoothstep
    
    #if USE_RADIAL_MASK // STATIC_SWITCH: USE_RADIAL_MASK
        float var118 =  var117;
    #else
        float var118 =  var86;
    #endif
    
    float var119 = var107 * var118; // Multiply
    float var120 = var87 * var119; // Multiply
    float2 var121 = Parameter9.xy; // PinWheel_SmoothStep
    float2 var122;
    { // (UVCoord)
    float2 result = defaultUVs;
    var122 = result;
    }
    float2 var123 = Parameter9.zw; // PinWheel_Center
    float2 var124 = var122 + var123; // Add
    float2 var125;
    { // (simpleRemapFloat2)
    float2 input = var124;
    float2 result = float2(input.x*2-1, input.y*2-1);
    var125 = result;
    }
    float var126 = var125.x; // Mask
    float2 var127 = Parameter10.xy; // PinWheelNoise_MinMax
    float2 var128;
    { // (UVCoord)
    float2 result = defaultUVs;
    var128 = result;
    }
    float2 var129 = Parameter5.xy; // PinWheel_Noise_Tile
    float2 var130 = var128 * var129; // Multiply
    float4 var131 = TIME; // Time
    float2 var132 = Parameter10.zw; // PinWheelNoise_Speed
    float2 var133;
    { // (Panner)
    float2 uvInput = var130;
    float time = var131.x;
    float2 speed = var132;
    float2 scroll = float2( ( time * speed.x + uvInput.x ), ( time * speed.y + uvInput.y ));
    float2 result = scroll;
    var133 = result;
    }
    float4 var134 = tex2D(Noise_Texture, var133); // Noise_Texture
    float var135 = lerp(var127.x, var127.y, var134.y); // Lerp
    float var136 = var126 + var135; // Add
    
    #if USE_PINWHEEL_MASK_NOISE // STATIC_SWITCH: USE_PINWHEEL_MASK_NOISE
        float var137 =  var136;
    #else
        float var137 =  var126;
    #endif
    
    float var138 = var125.y; // Mask
    float var139 = var135 + var138; // Add
    
    #if USE_PINWHEEL_MASK_NOISE // STATIC_SWITCH: USE_PINWHEEL_MASK_NOISE
        float var140 =  var139;
    #else
        float var140 =  var138;
    #endif
    
    float var141 = atan2(var137,var140); // atan2
    float var142 = 6.283185482; // 2pi
    float var143 = var141 / var142; // Divide
    float var144 = interpolants.interp_0.z; // EvaluateInVertexShader
    float var145 = var143 + var144; // Add
    float var146 = Parameter8.w; // PinWheel_Segments
    float var147 = var142 * var146; // Multiply
    float var148 = var145 * var147; // Multiply
    float var149 = sin(var148); // sin
    float var150;
    { // (simpleRemap)
    float input = var149;
    float result = ( input + 1 ) * 0.5;
    var150 = result;
    }
    float var151 = smoothstep(var121.x, var121.y, var150); // smoothstep
    
    #if USE_PINWHEEL_MASK // STATIC_SWITCH: USE_PINWHEEL_MASK
        float var152 =  var151;
    #else
        float var152 =  var86;
    #endif
    
    float var153 = var120 * var152; // Multiply
    float var154 = var59 * var153; // Multiply
    
    #if USE_RECT_MASK // STATIC_SWITCH: USE_RECT_MASK
        float var155 =  var154;
    #else
        float var155 =  var153;
    #endif
    
    float var156 = var34 * var155; // Multiply
    
    #if USE_SCANLINES // STATIC_SWITCH: USE_SCANLINES
        float var157 =  var156;
    #else
        float var157 =  var155;
    #endif
    
    float var158 = 0; // FloatLiteral
    
    #if USE_RADIALNOISE_MASK // STATIC_SWITCH: USE_RADIALNOISE_MASK
        float var159 =  var85;
    #else
        float var159 =  var158;
    #endif
    
    
    #if USE_LINEAR_MASK // STATIC_SWITCH: USE_LINEAR_MASK
        float var160 =  var106;
    #else
        float var160 =  var158;
    #endif
    
    
    #if USE_RADIAL_MASK // STATIC_SWITCH: USE_RADIAL_MASK
        float var161 =  var117;
    #else
        float var161 =  var158;
    #endif
    
    float var162 = max(var160,var161); // max
    float var163 = max(var159,var162); // max
    
    #if USE_PINWHEEL_MASK // STATIC_SWITCH: USE_PINWHEEL_MASK
        float var164 =  var151;
    #else
        float var164 =  var158;
    #endif
    
    float var165 = max(var163,var164); // max
    float var166 = max(var165,var59); // max
    
    #if USE_RECT_MASK // STATIC_SWITCH: USE_RECT_MASK
        float var167 =  var166;
    #else
        float var167 =  var165;
    #endif
    
    float var168 = max(var34,var167); // max
    
    #if USE_SCANLINES // STATIC_SWITCH: USE_SCANLINES
        float var169 =  var168;
    #else
        float var169 =  var167;
    #endif
    
    
    #if TOGGLE_MASK_MULT_MAX // STATIC_SWITCH: TOGGLE_MASK_MULT_MAX
        float var170 =  var157;
    #else
        float var170 =  var169;
    #endif
    
    float var171 = smoothstep(var1.x, var1.y, var170); // smoothstep
    float var172 = saturate(var171); // saturate
    float2 var173 = Parameter11.xy; // Scale_MinMax
    float var174 = Parameter11.z; // Scale_Speed
    float4 var175 = TIME; // Time
    float var176 = var174 * var175.x; // Multiply
    float var177 = sin(var176); // sin
    float var178;
    { // (simpleRemap)
    float input = var177;
    float result = ( input + 1 ) * 0.5;
    var178 = result;
    }
    float var179 = lerp(var173.x, var173.y, var178); // Lerp
    float2 var180 = float2(var179,var179); // Splat
    float2 var181 = Parameter12.xy; // Scale_Center
    float var182 = Parameter11.w; // UV_Background_Zoom
    float var183 = 1; // FloatLiteral
    float var184 = lerp(var182, var183, var171); // Lerp
    float2 var185 = Parameter12.zw; // UV_Distortion_MinMax
    float var186 = lerp(var185.x, var185.y, var171); // Lerp
    float2 var187;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var187 = result;
    }
    float var188 = var187.x; // Mask
    float var189 = var186 + var188; // Add
    float var190 = var187.y; // Mask
    float var191 = var186 + var190; // Add
    float2 var192 = float2(var189,var191); // Combine
    float2 var193 = float2(-0.5,-0.5); // Float2Literal
    float2 var194 = var192 + var193; // Add
    float2 var195 = var184 * var194; // Multiply
    float2 var196 = var195 - var193; // Subtract
    float2 var197;
    { // (UVCoord)
    float2 result = defaultUVs;
    var197 = result;
    }
    float var198 = var197.x; // Mask
    float var199 = Parameter13.x; // RefractionNoise_Distance
    float var200 = var198 + var199; // Add
    float var201 = 10; // FloatLiteral
    float2 var202;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var202 = result;
    }
    float var203 = Parameter13.y; // RefractionNoiseSize
    float2 var204 = var202 * var203; // Multiply
    float4 var205 = tex2D(Noise_Texture, var204); // Noise_Texture
    float var206 = interpolants.interp_0.w; // EvaluateInVertexShader
    float var207 = var206 + var198; // Add
    float var208 = var205.z + var207; // Add
    float var209 = var201 * var208; // Multiply
    float var210 = sin(var209); // sin
    float var211;
    { // (simpleRemap)
    float input = var210;
    float result = ( input + 1 ) * 0.5;
    var211 = result;
    }
    float var212 = lerp(var200, var198, var211); // Lerp
    float var213 = var197.y; // Mask
    float2 var214 = float2(var212,var213); // Combine
    float2 var215;
    { // (UIOriginalTexCoords)
    float2 result = orginalTexCoords;
    var215 = result;
    }
    
    #if ENABLE_REFRACT_BG // STATIC_SWITCH: ENABLE_REFRACT_BG
        float2 var216 =  var214;
    #else
        float2 var216 =  var215;
    #endif
    
    
    #if WARPS_BG_UVS_WITH_MASK // STATIC_SWITCH: WARPS_BG_UVS_WITH_MASK
        float2 var217 =  var196;
    #else
        float2 var217 =  var216;
    #endif
    
    float2 var218 = var181 + var217; // Add
    float2 var219 = var180 * var218; // Multiply
    float2 var220 = abs(var181); // abs
    float2 var221 = var219 + var220; // Add
    
    #if SCALE_BG // STATIC_SWITCH: SCALE_BG
        float2 var222 =  var221;
    #else
        float2 var222 =  var217;
    #endif
    
    float4 var223 = tex2D(Mask_Texture, var222); // Mask_Texture
    float var224 = Parameter13.z; // Blue_Channel_BG_Offset
    float var225 = var223.z + var224; // Add
    float var226 = saturate(var225); // saturate
    float var227 = var172 * var226; // Multiply
    float var228 = max(var171,var226); // max
    
    #if TOGGLE_MULT_MAX_BLUE_CHANNEL // STATIC_SWITCH: TOGGLE_MULT_MAX_BLUE_CHANNEL
        float var229 =  var227;
    #else
        float var229 =  var228;
    #endif
    
    
    #if USE_BLUE_CHANNEL_BG // STATIC_SWITCH: USE_BLUE_CHANNEL_BG
        float var230 =  var229;
    #else
        float var230 =  var171;
    #endif
    
    float4 var231 = float4(var230,var230,var230,var230); // Splat
    float4 var232 = Parameter14.xyzw; // BG_FlatColor
    float4 var233;
    { // (UIPrimaryTexture)
    float2 uvs = var222;
    
    float4 result = tex2D(UI_PRIMARY_TEXTURE, uvs);
    var233 = result;
    }
    
    #if TOGGLE_COLOR_ICON_BG // STATIC_SWITCH: TOGGLE_COLOR_ICON_BG
        float4 var234 =  var232;
    #else
        float4 var234 =  var233;
    #endif
    
    float4 var235 = Parameter15.xyzw; // BGColor_A
    float4 var236 = Parameter16.xyzw; // BGColor_B
    float4 var237 = lerp(var235, var236, var230); // Lerp
    float2 var238 = Parameter17.xy; // Background_MinMax
    float var239 = saturate(var171); // saturate
    float var240 = lerp(var238.x, var238.y, var239); // Lerp
    float4 var241 = var237 * var240; // Multiply
    float var242 = saturate(var230); // saturate
    float4 var243 = lerp(var234, var241, var242); // Lerp
    float2 var244 = float2(-0.01,0.01); // Float2Literal
    float2 var245 = float2(0.01,-0.01); // Float2Literal
    float var246 = 4; // FloatLiteral
    float4 var247 = TIME; // Time
    float var248 = var246 * var247.x; // Multiply
    float var249 = sin(var248); // sin
    float var250;
    { // (simpleRemap)
    float input = var249;
    float result = ( input + 1 ) * 0.5;
    var250 = result;
    }
    float2 var251 = lerp(var244, var245, var250); // Lerp
    
    #if ENABLE_REFRACT_FG // STATIC_SWITCH: ENABLE_REFRACT_FG
        float2 var252 =  var214;
    #else
        float2 var252 =  var215;
    #endif
    
    
    #if WARPS_FG_UVS_WITH_MASK // STATIC_SWITCH: WARPS_FG_UVS_WITH_MASK
        float2 var253 =  var196;
    #else
        float2 var253 =  var252;
    #endif
    
    float2 var254 = var253 + var181; // Add
    float2 var255 = var180 * var254; // Multiply
    float2 var256 = var255 + var220; // Add
    
    #if SCALE_FG // STATIC_SWITCH: SCALE_FG
        float2 var257 =  var256;
    #else
        float2 var257 =  var253;
    #endif
    
    float2 var258 = var251 + var257; // Add
    
    #if TRANSLATE_FG // STATIC_SWITCH: TRANSLATE_FG
        float2 var259 =  var258;
    #else
        float2 var259 =  var257;
    #endif
    
    float4 var260;
    { // (UIPrimaryTexture)
    float2 uvs = var259;
    
    float4 result = tex2D(UI_PRIMARY_TEXTURE, uvs);
    var260 = result;
    }
    float4 var261 = tex2D(Mask_Texture, var259); // Mask_Texture
    float4 var262 = lerp(var243, var260, var261.y); // Lerp
    float4 var263 = Parameter18.xyzw; // FG_Color_A
    float2 var264 = Parameter17.zw; // Foreground_MinMax
    float var265 = saturate(var171); // saturate
    float var266 = lerp(var264.x, var264.y, var265); // Lerp
    float4 var267 = var263 * var266; // Multiply
    float4 var268 = tex2D(Mask_Texture, var214); // Mask_Texture
    float4 var269 = lerp(var262, var267, var268.x); // Lerp
    
    #if TOGGLE_COLOR_ICON_BG // STATIC_SWITCH: TOGGLE_COLOR_ICON_BG
        float4 var270 =  var263;
    #else
        float4 var270 =  var232;
    #endif
    
    float4 var271 = var266 * var270; // Multiply
    float var272 = var265 * var261.x; // Multiply
    float4 var273 = lerp(var262, var271, var272); // Lerp
    
    #if USE_RED_CHANNEL_FG // STATIC_SWITCH: USE_RED_CHANNEL_FG
        float4 var274 =  var273;
    #else
        float4 var274 =  var262;
    #endif
    
    
    #if USE_RED_CHANNEL_REFRACT // STATIC_SWITCH: USE_RED_CHANNEL_REFRACT
        float4 var275 =  var269;
    #else
        float4 var275 =  var274;
    #endif
    
    
    #if PREVIEW_MASK // STATIC_SWITCH: PREVIEW_MASK
        float4 var276 =  var231;
    #else
        float4 var276 =  var275;
    #endif
    
    float var277 = 1; // FloatLiteral
    float4 var278 = float4(var276.xyz,var277); // Combine
    
    #ifdef LOW_QUALITY_MODE
        float4 var279 =  var0;
    #else
        float4 var279 =  var278;
    #endif
    
    
    float4 texColor = var279;
    texColor *= interpolants.perVertexColor;

    float4 out_color;
#ifdef UI_OPAQUE
    out_color = float4(texColor.rgb * UI_COLOR.rgb, 1);
#else
    // handle the fact that UI uses a pre-multiplied alpha blend mode
    out_color = float4(texColor.rgb * texColor.a * UI_COLOR.rgb * UI_COLOR.a, texColor.a * UI_COLOR.a);
#endif

    

    return out_color;
}
