#include "../ColorPalette.hls"
#include "../DeathScreen.hls"
#include "../MipLevels.hls"
#include "../FogOfWar/FogOfWar_PS.hls"
#include "SoftParticle.hls"
#include "ColorRemap.hls"
#include "AlphaErode.hls"
#include "navmeshmask_ps.hls"
#include "AlphaTest_ps.hls"

#ifdef REFLECTIVE
float4  vReflectionFColor;
#endif

sampler2D TEXTURE;
sampler2D PARTICLE_COLOR_TEXTURE;
#ifdef REFLECTIVE
    samplerCUBE REFLECTION_MAP;
#endif
#ifdef  MULT_PASS
sampler2D TEXTUREMULT;
#endif

float2 COLOR_LOOKUP_UV;
float4 FRESNEL;


#if defined(COLORPALETTE_COLORBLIND)
   float4 APPLY_TEAM_COLOR_CORRECTION;
#endif

struct INTERPOLANTS
{
    float4  position        : POSITION;
    float4  color0          : TEXCOORD0;    // N.B. colors can be > 1 (e.g. mod2x), so use a full interpolator and not COLOR0 which saturates on ps_2_0

    float3  uv0_positionW   : TEXCOORD1;
    // xy = uv0
    // z  = projection W, eye z used to compensate for perspective correction for screen space uv

#ifndef DISABLE_FOW
    float3  uvFOW_fadeFOW   : TEXCOORD2;    // FOW: xy = uv, z = height based fade in
#endif

    // define TEXCOORD3 according to shader variant to minimize interpolators
#if defined( SEPARATE_ALPHA_UV ) && defined( MULT_PASS )
    float4  uvMult_uvAlpha  : TEXCOORD3;
#elif defined( SEPARATE_ALPHA_UV )
    float2  uvAlpha         : TEXCOORD3;
#elif defined( MULT_PASS )
    float2  uvMult          : TEXCOORD3;
#endif

#ifdef REFLECTIVE
    float4  reflectRay      : TEXCOORD4;
#endif

#ifdef SOFT_PARTICLES
    float3  projPositionXYZ : TEXCOORD7;
#endif

#ifdef MASKED
    float2  maskUVs         : TEXCOORD5;
#endif

    float3  fresnelColor    : TEXCOORD6;    // fresnel based rim effect available even w/o reflection map
};

float4 main(INTERPOLANTS interpolants) : COLOR0
{
    // extract inputs from interpolators (variant dependent)
    float2 uv0      = interpolants.uv0_positionW.xy;
#if defined( SEPARATE_ALPHA_UV ) && defined( MULT_PASS )
    float2 uvMult   = interpolants.uvMult_uvAlpha.xy;
    float2 uvAlpha  = interpolants.uvMult_uvAlpha.zw;
#elif defined( SEPARATE_ALPHA_UV )
    float2 uvAlpha  = interpolants.uvAlpha.xy;
#elif defined( MULT_PASS )
    float2 uvMult   = interpolants.uvMult.xy;
#endif
 
#ifdef SCREEN_SPACE_UV
    // correct texture coordinates
    float projW = interpolants.uv0_positionW.z;
    float correction = 1/projW; // @todo supply inverse to interpolator instead
    uv0 *= correction;
    #ifdef SEPARATE_ALPHA_UV
        uvAlpha *= correction;
    #endif
    // mult texture is anchored to the model, so it isn't corrected here
#endif

    float4 texel = tex2D(TEXTURE, uv0);
#ifdef SEPARATE_ALPHA_UV    
    texel.w = tex2D(TEXTURE, uvAlpha).w;    
#endif

#ifdef PALETTIZE_TEXTURES
    // remap textures according to palettization settings
    texel.rgb = ColorizeMainTexture(texel).rgb;
#endif

#ifdef MULT_PASS
    float4 particle_color_texel = tex2D(TEXTUREMULT, uvMult);
    texel *= particle_color_texel;
#elif !defined(ALPHA_EROSION)
    // apply p-rgba colorizing texture (if not using alpha erosion which uses same sampler)
    // @todo investigate discrepancy with quad shader which also applies color texture when using mult
    float4 particle_color_texel = tex2D(PARTICLE_COLOR_TEXTURE, COLOR_LOOKUP_UV);
    texel *= particle_color_texel;
#endif
    float4 out_color0 = interpolants.color0 * texel;

    //**
    // color palette transforms
#ifdef COLORPALETTE_COLORBLIND
    if (APPLY_TEAM_COLOR_CORRECTION.r != 0.0f)
    {
        ApplyColorCorrectionColorblind(out_color0);
    }
#endif 

    //**
    // Reflection
#ifdef REFLECTIVE
    //This reflection vector is used to look up the Reflection color in the cube map.
    //This color is scaled by opacity stored in eyeRay.w (computed in the vertex shader).
    float3 reflectionColor = texCUBE(REFLECTION_MAP, interpolants.reflectRay.xyz).rgb * interpolants.reflectRay.w;

    //the view dependent reflection color is keyed off the fresnel.
    float3 reflTint = lerp(1.0f, vReflectionFColor.rgb, interpolants.reflectRay.w);

    //Finally the reflection color is modified by the RGB Reflection Tint (computed in the vertex shader)
    //and added to the pixel color (finalColor).
    out_color0.rgb += reflectionColor*reflTint;
#endif
    out_color0.rgb += interpolants.fresnelColor * out_color0.a;    // add fresnel rim effect (available even w/o a reflection map)

    //**
    // Fog of War
#ifndef DISABLE_FOW 
#ifdef SCREEN_SPACE_UV
    float4 fowFactors = GetFogOfWarFactors(interpolants.uvFOW_fadeFOW.xy);
#else
    float fowFadeInFactorByHeight = interpolants.uvFOW_fadeFOW.z;
    float4 fowFactors = GetFogOfWarFactorsWithFadeTowardFogged(interpolants.uvFOW_fadeFOW.xy, fowFadeInFactorByHeight);
#endif

    // Apply FOW to final result
    // NOTE:  This ignores the FowOverlay texture tint and assumes the FoW is black
    out_color0.rgb *= fowFactors.a;
#endif

#ifdef ALPHA_EROSION
    out_color0.a *= CalcAlphaErosionForMesh(uv0);
#endif

    //**
    // soft particles
#ifdef SOFT_PARTICLES
    float4 projPosition = float4(interpolants.projPositionXYZ, interpolants.uv0_positionW.z);
    out_color0 = CalcSoftParticleColor(projPosition,out_color0);
#endif

    //**
    // Finalize output color
    out_color0.rgb = saturate(out_color0.rgb); // @todo should we be saturating before these in all shaders?
    out_color0.rgb = ApplyMipColorsVisualization(out_color0.rgb, uv0);
    
#ifdef MASKED
    out_color0 = ApplyNavmeshMask(out_color0, interpolants.maskUVs);
#endif

#ifndef PS_2_0
    AlphaTest(out_color0);
#endif

    return out_color0;
}
