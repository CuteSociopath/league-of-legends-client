#include "../ColorPalette.hls"
#include "../DeathScreen.hls"
#include "../MipLevels.hls"
#include "AlphaTest_ps.hls"

// NOTE:
// The 'Alpha Erosion' feature should generally be preferred over this legacy
// alpha slice feature since it works in conjunction with other effects features
// and is more flexible (e.g., uses an independent erosion map)

sampler2D TEXTURE;
sampler2D PARTICLE_COLOR_TEXTURE;
sampler2D SAMPLER_FOW;

float2  SLICE_RANGE;

#if defined(COLORPALETTE_COLORBLIND)
   float4 APPLY_TEAM_COLOR_CORRECTION;
#endif

struct INTERPOLANTS
{
    float4  position    : POSITION;
    float4  color0      : TEXCOORD0;    // N.B. colors can be > 1 (e.g. mod2x), so use a full interpolator and not COLOR0 which saturates on ps_2_0
    float4  uv0_uv1     : TEXCOORD1;
#ifdef MASKED
    float4  uvFOW_uvMap : TEXCOORD2;    // zw here is being used for navmesh masking if it's enabled
#else
    float2  uvFOW       : TEXCOORD2;
#endif
};

float4 main(INTERPOLANTS interpolants) : COLOR0
{
    float2 uv0 = interpolants.uv0_uv1.xy;
    float2 uv1 = interpolants.uv0_uv1.zw;

    float4 colorization = tex2D(PARTICLE_COLOR_TEXTURE, uv1);
    float timeAlpha = colorization.a;
    float4 out_color0 = interpolants.color0 * colorization;
    
    // This is essentially a 1-X^2 windowing function offset with the slice sample
    // and the width controlled by the p-alphaslicerange key
    //     ^
    //  1  |           o
    //     |        o    o 
    //     |       o      o
    // 0  +-oooooo---------oooooo---->
      
    float4 sliceSample = tex2D(TEXTURE, uv0);
    float sliceAlpha = (sliceSample.r - timeAlpha);
    sliceAlpha = (sliceAlpha + SLICE_RANGE.x) * (SLICE_RANGE.x - sliceAlpha) * SLICE_RANGE.y;
    out_color0.a = saturate(sliceSample.a * sliceAlpha);
    
    // Apply FOW to final result
    // @todo this currently does not honor the FowOverlay texture
#ifndef DISABLE_FOW

#ifdef MASKED
    float4 texelFOW = tex2D(SAMPLER_FOW, interpolants.uvFOW_uvMap.xy);
#else
    float4 texelFOW = tex2D(SAMPLER_FOW, interpolants.uvFOW);
#endif
    
    // Note inconsistent behavior between quad and mesh primitives with slice:
    // quad primitives tint with the green channel of the slice texture, mesh primitives do not?
    out_color0.xyz *= texelFOW.aaa * sliceSample.g;
#else
    out_color0.xyz *= sliceSample.g;
#endif
    
#ifdef COLORPALETTE_COLORBLIND
    if (APPLY_TEAM_COLOR_CORRECTION.r != 0.0f)
    {   
        ApplyColorCorrectionColorblind(out_color0);
    }
#endif 
        
    out_color0.rgb = ApplyMipColorsVisualization(out_color0.rgb, uv0);

    AlphaTest(out_color0);

    return out_color0;
}
