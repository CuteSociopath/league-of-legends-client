#include "IOParam/IODefine_VS.hls"
#include "../Fog/Fog.hls"
#include "../FogOfWar/FogOfWar_VS.hls"
#include "../Lighting/Lighting.hls"
#include "skinning.hls"
#include "unpack.hls"

#ifdef LOW_QUALITY_MODE
    #define NO_LIGHTING
    #define DISABLE_SHADOWS
    #undef FOG_PIXELSHADER_BLEND
    #undef REFLECTIVE
#endif


#ifdef REFLECTIVE
float4  vReflection;
float4  vReflectionFColor;
#endif

// Fresnel Parameters
// set from R3D_SHADER_VS_CONSTANT_FRESNEL in C++ code
float4  vFresnel;    // FresnelRed, FresnelGreen, FresnelBlue, FresnelPower

struct VERTEX
{
    float3		    vPos            : X3D_VSIN_POSITION;
    float4		    vBlendWeight    : X3D_VSIN_BLENDWEIGHT;
    float3		    vNormal         : X3D_VSIN_NORMAL;
    blendindex4	    vBlendIndices   : X3D_VSIN_BLENDINDICES;
    float2		    vUV1            : X3D_VSIN_TEXCOORD0;
};

struct INTERPOLANTS
{
    float4    position      : POSITION;
#ifndef NO_LIGHTING
    float4  lightingColor      : COLOR0;
#endif
#if defined(FOG_PIXELSHADER_BLEND)
    float4  uv1           : TEXCOORD0;
#else
    float2  uv1           : TEXCOORD0;
#endif
    float2  worldXZ  : TEXCOORD2;
#ifdef  SEPARATE_ALPHA_UV
    float2  alphaUV       : TEXCOORD4;
#endif
#ifdef MRT_SUPPORTED
    float4  worldPosition  : TEXCOORD1;
#endif
#ifndef DISABLE_SHADOWS
    float3  shadowMapUV          : TEXCOORD3;
#endif
#ifdef REFLECTIVE
    float4  reflectRay    : TEXCOORD5;
    float3  reflTint      : TEXCOORD7;
#endif
};

/////////////////////////////////////////////////////////////////////////////////////
///
///
///
/////////////////////////////////////////////////////////////////////////////////////
INTERPOLANTS main(VERTEX vertex)
{
    INTERPOLANTS interpolants;

#if EXPERIMENTAL_UNPACK_VERTS
    UnpackAttributes(vertex.vBlendWeight, vertex.vNormal, vertex.vUV1);     // unpack fixed point attributes
#endif

    float3 worldPosition;
    float3 worldNormal;
#ifndef NO_SKINNING
    SkinPositionAndNormal(vertex.vPos, vertex.vNormal, vertex.vBlendIndices, vertex.vBlendWeight, worldPosition, worldNormal);
#else
    worldPosition = mul(float4(vertex.vPos, 1.f), BONES[0]);
    worldNormal = mul(float4(vertex.vNormal, 0.f), BONES[0]);
#endif


#ifdef MRT_SUPPORTED
    // Output world position
    interpolants.worldPosition.xyz = worldPosition.xyz;
#endif

    // Output homogeneous position
    interpolants.position = mul(float4(worldPosition.xyz, 1.0f), mProj);

    // Output texture coordinate using texture transform
    interpolants.uv1.xy = vertex.vUV1;

#ifdef SEPARATE_ALPHA_UV
    interpolants.alphaUV = vertex.vUV1;
#endif

#ifndef DISABLE_SHADOWS
    // Output shadow position
    interpolants.shadowMapUV = mul(float4(worldPosition.xyz, 1.0f), mShadowProj).xyz;
#endif

#ifndef NO_LIGHTING
    #ifdef USE_LIGHT_GRID
        float3 lighting = LightingLightGrid(worldNormal);
    #else
        float3 lighting = LightingSunLight(worldNormal);
    #endif
    interpolants.lightingColor = float4(lighting,0);
#endif

    // Fog of war
    interpolants.worldXZ.xy = FogOfWarTextureCoordinates(worldPosition.xyz).xy;


    float3 eyeRay = normalize(worldPosition.xyz - vCamera.xyz);


#ifdef REFLECTIVE
    float reflectFresnelPower = vReflection.x;
    interpolants.reflectRay.xyz = reflect(eyeRay, worldNormal.xyz);

    //store the fresnel factor in the w component of the reflectRay. This is done in the vertex shader, so a proper power can be used.
    //base fresnel is the 0 to 1 reflection intensity based on the fresnel power.
    float baseReflectFresnel = 1.0f - pow(saturate(dot(-eyeRay, worldNormal.xyz)), reflectFresnelPower);
    //the final scaled result factors in the minimum and maximum reflection intensities supplied by the artists.
    interpolants.reflectRay.w = lerp(vReflection.y, vReflection.z, baseReflectFresnel);
    //the view dependent reflection color is also keyed off the fresnel.
    interpolants.reflTint = lerp(1.0f, vReflectionFColor.rgb, interpolants.reflectRay.w);
#endif

#if defined(FOG_PIXELSHADER_BLEND)
    interpolants.uv1.zw = interpolants.worldXZ.xy;
    interpolants.uv1.w = 1.0f - interpolants.uv1.w;
#ifndef NO_LIGHTING
    interpolants.lightingColor.a = 1.0f - ComputeFogValue(interpolants.position, worldPosition.xyz);
#endif
#endif

#ifdef MRT_SUPPORTED
    float fresnelPower = vFresnel.w;
    float baseFresnel = 1.0f - pow(saturate(dot(-eyeRay, worldNormal.xyz)), fresnelPower);
    interpolants.worldPosition.w = baseFresnel;  // store fresnel factor in position w
#endif

    return interpolants;
}
