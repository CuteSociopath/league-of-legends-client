////////////////////////////////////////////////////////////////////////////////////////////////////
//This shader blurs the shadow mask to smooth out the shadow edges
//and dilates the depth, so those edges are not cutoff at the mid-point.
//Obviously this only works if the objects casting shadows are "sparse" and the objects
//recieving shadows do not also cast shadows (objects casting and recieving shadows will still have
//hard edges visible).
////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../ShadowMap/pcf1.hls"

float2 UVStep;

struct INTERPOLANTS
{
    float4        position     : POSITION;
    float2        texcoord0    : TEXCOORD0;
};


float4 main(INTERPOLANTS interpolants) : COLOR0
{    
	//This blur filter is hard coded to 3 taps, it is expected that 2 (or more) passes
	//will be used with appropriate texture coordinates to generate a 3x3 seperable filter.
        float4 s0 = tex2D(ShadowMapBlurInput, interpolants.texcoord0 - UVStep);
        float4 s1 = tex2D(ShadowMapBlurInput, interpolants.texcoord0);
        float4 s2 = tex2D(ShadowMapBlurInput, interpolants.texcoord0 + UVStep);
	
	//Compute all the depth values, the minimum depth will be written out for this pixel (dilation).
	float3 depth = float3( unpackFloatFromVec3(s0.xyz), unpackFloatFromVec3(s1.xyz), unpackFloatFromVec3(s2.xyz) );
	
	float3 smin = s2.xyz;
	if (depth.x <= depth.y)
	{
		if (depth.x <= depth.z)
		{
			smin = s0.xyz;
		}
	}
	else if (depth.y < depth.x)
	{
		if (depth.y <= depth.z)
		{
			smin = s1.xyz;
		}
	}
	
	//The mask is blurred - which generates smooth edges for the shadows.
	float3 mask = float3( s0.a, s1.a, s2.a );
	
	const float filteredWeight = (mask.x + mask.z) * 0.25f + (mask.y * 0.5f);
	return float4( smin, filteredWeight );
}
